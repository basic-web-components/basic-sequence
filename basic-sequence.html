<link rel="import" href="../basic-modes/basic-modes.html">

<polymer-element name="basic-sequence" extends="basic-modes" attributes="canGoNext canGoPrevious">

<template>
  <style>
  ::content {
    /*transform: translateX(0);*/
  }

  ::content :not(.core-selected) {
    display: block;
    left: 0;
    position: absolute;
    visibility: hidden;
  }

  ::content .waiting {
    visibility: visible;
  }
  ::content .offStage {
    transition: transform 0.05s;
  }
  ::content .offStagePrevious {
    transform: translateX(-100%);
  }
  ::content .centerStage {
    transform: translateX(0);
  }
  ::content .offStageNext {
    transform: translateX(100%);
  }
  ::content .sequenceTransition {
    transition: transform 1s;
    visibility: visible;
  }
  </style>
  <shadow></shadow>
</template>

<script>
Polymer( "basic-sequence", {

  /**
   * True if it there is at least one child after the active one.
   *
   * @property canGoNext
   */
  // TODO: This property and its companion canGoPrevious should be read-only,
  // but it's not clear how to create a bindable, read-only property.
  // See http://stackoverflow.com/questions/23900203/easiest-way-for-a-polymer-element-to-declare-a-bindable-property-with-a-getter-s.
  canGoNext: false,
  get _canGoNext() {
    return ( this.selectedIndex + 1 < this.distributedChildren.length );
  },

  /**
   * True if it there is at least one child after the active one. Read-only.
   *
   * @property canGoPrevious
   */
  // TODO: See note at canGoNext.
  canGoPrevious: false,
  get _canGoPrevious() {
    return ( this.selectedIndex > 0 );
  },

  /**
   * Move to the next child in the sequence of children.
   * If the last child is already the active one being shown, this has no effect.
   *
   * @method next
   */
  next: function() {
    if ( this.canGoNext ) {
      this.selected = this.selectedIndex + 1;
    }
  },

  ready: function() {
    // TODO: Support Safari with "webkitTransitionEnd". Don't wire up both on Chrome.
    // this.addEventListener( "webkitTransitionEnd", function() {
    //   console.log( "webkitTransitionEnd" );
    // });
    this.addEventListener( "transitionend", function( event ) {
      this._transitionComplete( event.target );
    }.bind( this ));
  },

  selectedIndexChanged: function() {
    this.super();
    this.canGoNext = this._canGoNext;
    this.canGoPrevious = this._canGoPrevious;
    var selectedIndex = this.selectedIndex;
    Array.prototype.forEach.call( this.items, function( item, index ) {
      item.classList.toggle( "offStagePrevious", index < selectedIndex );
      item.classList.toggle( "offStageNext", index > selectedIndex );
    });
    this._transitionToIndex( this.selectedIndex );
  },

  /**
   * Move to the previous child in the sequence of children.
   * If the first child is already the active one being shown, this has no effect.
   *
   * @method previous
   */
  previous: function() {
    if ( this.canGoPrevious ) {
      this.selected = this.selectedIndex - 1;
    }
  },

  _transitionStart: function( direction, oldItem, newItem ) {
    var duration = 300;
    // var player = document.timeline.play( new Animation( oldItem, [
    //   { opacity: "1" },
    //   { opacity: "0" }
    // ], duration ));
    // var player = document.timeline.play( new Animation( newItem, [
    //   { opacity: "0" }, 
    //   { opacity: "1" }
    // ], duration ));
    // var slideOut = direction ? "-100%": "100%";
    // var playerOld = document.timeline.play( new Animation( oldItem, [
    //   { transform: "translateX(0)" },
    //   { transform: "translateX(" + slideOut + ")" }
    // ], {
    //   duration: duration,
    //   easing: "ease"
    // }));
    // var slideIn = direction ? "100%" : "-100%";
    // var playerNew = document.timeline.play( new Animation( newItem, [
    //   { transform: "translateX(" + slideIn + ")" }, 
    //   { transform: "translateX(0)" }
    // ], {
    //   duration: duration,
    //   easing: "ease"
    // }));
    // oldItem.addEventListener( "webkitTransitionEnd", function() {
    //   console.log( "webkitTransitionEnd" );
    // });
    // oldItem.addEventListener( "transitionend", function() {
    //   console.log( "transitionend" );
    // });
    // oldItem.classList.add( "sequenceTransition" );
    // oldItem.classList.add( direction ? "offStagePrevious" : "offStageNext" );

    // this._oldItem = oldItem;
    // this._direction = direction;
    // oldItem.classList.add( "waiting" );
    // newItem.classList.add( "offStage" );
    // newItem.classList.add( direction ? "offStageNext" : "offStagePrevious" );

    oldItem.classList.add( "sequenceTransition" );
    oldItem.classList.add( direction ? "offStagePrevious" : "offStageNext" );
    newItem.classList.add( "sequenceTransition" );
    newItem.classList.remove( "offStagePrevious" );
    newItem.classList.remove( "offStageNext" );
    newItem.classList.add( "centerStage" );
  },

  _transitionComplete: function( element ) {
    // var oldItem = this._oldItem;
    // var direction = this._direction;
    // if ( element.classList.contains( "offStage" )) {
    //   // Start real transition.
    //   oldItem.classList.add( "sequenceTransition" );
    //   oldItem.classList.remove( "waiting" );
    //   oldItem.classList.add( direction ? "offStagePrevious" : "offStageNext" );
    //   element.classList.remove( "offStage" );
    //   element.classList.add( "sequenceTransition" );
    // } else {
    //   element.classList.remove( "sequenceTransition" );
    // }
    // element.classList.remove( "offStagePrevious" );
    // element.classList.remove( "offStageNext" );
    element.classList.remove( "sequenceTransition" );
  },

  _transitionToIndex: function( newIndex ) {
    var oldIndex = this._previousSelectionIndex;
    this._previousSelectionIndex = newIndex;
    if ( oldIndex == null ) {
      // First time selecting, no slide necessary.
      return;
    }
    if ( newIndex === oldIndex ) {
      // We shouldn't have received an event in this case, but just in case...
      return;
    }
    var direction = ( newIndex > oldIndex );
    var items = this.items;
    var oldItem = items[ oldIndex ];
    var newItem = items[ newIndex ];
    var arrow = direction ? " -> " : " <- ";
    console.log( oldIndex + arrow + newIndex );
    this._transitionStart( direction, oldItem, newItem );
  },

  _previousSelectionIndex: null

});
</script>

</polymer-element>
